;; Compiled expression:
(compile '(lambda (+ * a b x y)
            (+ (* a x) (* b y))) 'val 'next the-empty-compile-time-env)

;; Before checking compile-time-env for implementations
((env) (val) ((assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign argl (op append) (reg argl) (const ())) (assign env (op extend-environment) (const (+ * a b x y)) (reg argl) (reg env)) (assign val (op lexical-address-lookup) (const (0 . 2)) (reg env)) (assign arg1 (op lexical-address-lookup) (const (0 . 4)) (reg env)) (assign val (op *) (reg val) (reg arg1)) (save val) (assign val (op lexical-address-lookup) (const (0 . 3)) (reg env)) (assign arg1 (op lexical-address-lookup) (const (0 . 5)) (reg env)) (assign val (op *) (reg val) (reg arg1)) (assign arg1 (reg val)) (restore val) (assign val (op +) (reg val) (reg arg1)) (goto (reg continue)) after-lambda1))

;; After (we lookup the implementations in the env when they are exist)
((env) (val) ((assign val (op make-compiled-procedure) (label entry2) (reg env)) (goto (label after-lambda1)) entry2 (assign env (op compiled-procedure-env) (reg proc)) (assign env (op extend-environment) (const (+ * a b x y)) (reg argl) (reg env)) (assign proc (op lexical-address-lookup) (const (0 . 0)) (reg env)) (save continue) (save proc) (save env) (assign proc (op lexical-address-lookup) (const (0 . 1)) (reg env)) (assign val (op lexical-address-lookup) (const (0 . 5)) (reg env)) (assign argl (op list) (reg val)) (assign val (op lexical-address-lookup) (const (0 . 3)) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch8)) compiled-branch7 (assign continue (label after-call6)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch8 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call6 (assign argl (op list) (reg val)) (restore env) (save argl) (assign proc (op lexical-address-lookup) (const (0 . 1)) (reg env)) (assign val (op lexical-address-lookup) (const (0 . 4)) (reg env)) (assign argl (op list) (reg val)) (assign val (op lexical-address-lookup) (const (0 . 2)) (reg env)) (assign argl (op cons) (reg val) (reg argl)) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch5)) compiled-branch4 (assign continue (label after-call3)) (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch5 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) after-call3 (restore argl) (assign argl (op cons) (reg val) (reg argl)) (restore proc) (restore continue) (test (op primitive-procedure?) (reg proc)) (branch (label primitive-branch11)) compiled-branch10 (assign val (op compiled-procedure-entry) (reg proc)) (goto (reg val)) primitive-branch11 (assign val (op apply-primitive-procedure) (reg proc) (reg argl)) (goto (reg continue)) after-call9 after-lambda1))
